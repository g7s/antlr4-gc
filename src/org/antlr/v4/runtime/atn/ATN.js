/*
 * Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

goog.module('org.antlr.v4.runtime.atn.ATN');
goog.module.declareLegacyNamespace();


const LL1Analyzer = goog.require('org.antlr.v4.runtime.atn.LL1Analyzer');
const Token = goog.require('org.antlr.v4.runtime.Token');
const Map = goog.require('org.antlr.v4.runtime.misc.Map');
const IntervalSet = goog.require('org.antlr.v4.runtime.misc.IntervalSet');

/** */
class ATN {
    /**
     * @param {number} grammarType
     * @param {number} maxTokenType
     */
    constructor(grammarType, maxTokenType) {
        /**
         * @type {!Array<org.antlr.v4.runtime.atn.ATNState>}
         */
        this.states = [];
        /**
         * Each subrule/rule is a decision point and we must track them so we
         * can go back later and build DFA predictors for them.  This includes
         * all the rules, subrules, optional blocks, ()+, ()* etc...
         *
         * @type {!Array<org.antlr.v4.runtime.atn.DecisionState>}
         */
        this.decisionToState = [];
        /**
         * Maps from rule index to starting state number.
         *
         * @type {!Array<org.antlr.v4.runtime.atn.RuleStartState>}
         */
        this.ruleToStartState = [];
        /**
         * Maps from rule index to stop state number.
         *
         * @type {!Array<org.antlr.v4.runtime.atn.RuleStopState>}
         */
        this.ruleToStopState = [];
        /**
         * @type {!Map<string, org.antlr.v4.runtime.atn.TokensStartState>}
         */
        this.modeNameToStartState = new Map();
        /**
         * The type of the ATN.
         *
         * @type {number}
         */
        this.grammarType = grammarType;
        /**
         * The maximum value for any symbol recognized by a transition in the ATN.
         *
         * @type {number}
         */
        this.maxTokenType = maxTokenType;
        /**
         * For lexer ATNs, this maps the rule index to the resulting token type.
         * For parser ATNs, this maps the rule index to the generated bypass token
         * type if the
         * {@link ATNDeserializationOptions#isGenerateRuleBypassTransitions}
         * deserialization option was specified; otherwise, this is {@code null}.
         *
         * @type {!Array<number>}
         */
        this.ruleToTokenType = [];
        /**
         * For lexer ATNs, this is an array of {@link LexerAction} objects which may
         * be referenced by action transitions in the ATN.
         *
         * @type {!Array<org.antlr.v4.runtime.atn.LexerAction>}
         */
        this.lexerActions = [];
        /**
         * @type {!Array<org.antlr.v4.runtime.atn.TokensStartState>}
         */
        this.modeToStartState = [];
    }

    /**
     * Compute the set of valid tokens that can occur starting in state {@code s}.
     * If {@code ctx} is null, the set of tokens will not include what can follow
     * the rule surrounding {@code s}. In other words, the set will be
     * restricted to tokens reachable staying within {@code s}'s rule.
     *
     * @param {org.antlr.v4.runtime.atn.ATNState} s
     * @param {org.antlr.v4.runtime.RuleContext=} ctx
     * @return {IntervalSet}
     */
    nextTokens(s, ctx) {
        if (goog.isDef(ctx)) {
            var anal = new LL1Analyzer(this);
            var next = anal.LOOKC(s, ctx);
            return next;
        } else {
            if (s.nextTokenWithinRule != null) return s.nextTokenWithinRule;
            s.nextTokenWithinRule = this.nextTokens(s, null);
            s.nextTokenWithinRule.setReadonly(true);
            return s.nextTokenWithinRule;
        }
    }

    /**
     * @param {org.antlr.v4.runtime.atn.ATNState} state
     * @return {void}
     */
    addState(state) {
        if (state != null) {
            state.atn = this;
            state.stateNumber = this.states.length;
        }

        this.states.push(state);
    }

    /**
     * @param {org.antlr.v4.runtime.atn.ATNState} state
     * @return {void}
     */
    removeState(state) {
        delete this.states[state.stateNumber]; // just free mem, don't shift states in list
    }

    /**
     * @param {org.antlr.v4.runtime.atn.DecisionState} s
     * @return {number}
     */
    defineDecisionState(s) {
        this.decisionToState.push(s);
        s.decision = this.getNumberOfDecisions() - 1;
        return s.decision;
    }

    /**
     * @param {number} decision
     * @return {org.antlr.v4.runtime.atn.DecisionState}
     */
    getDecisionState(decision) {
        if (this.getNumberOfDecisions() > 0) {
            return this.decisionToState[decision];
        }
        return null;
    }

    /**
     * @return {number}
     */
    getNumberOfDecisions() {
        return this.decisionToState.length;
    }

    /**
     * Computes the set of input symbols which could follow ATN state number
     * {@code stateNumber} in the specified full {@code context}. This method
     * considers the complete parser context, but does not evaluate semantic
     * predicates (i.e. all predicates encountered during the calculation are
     * assumed true). If a path in the ATN exists from the starting state to the
     * {@link RuleStopState} of the outermost context without matching any
     * symbols, {@link Token#EOF} is added to the returned set.
     *
     * <p>If {@code context} is {@code null}, it is treated as {@link ParserRuleContext#EMPTY}.</p>
     *
     * Note that this does NOT give you the set of all tokens that could
     * appear at a given token position in the input phrase.  In other words,
     * it does not answer:
     *
     *   "Given a specific partial input phrase, return the set of all tokens
     *    that can follow the last token in the input phrase."
     *
     * The big difference is that with just the input, the parser could
     * land right in the middle of a lookahead decision. Getting
     * all *possible* tokens given a partial input stream is a separate
     * computation. See https://github.com/antlr/antlr4/issues/1428
     *
     * For this function, we are specifying an ATN state and call stack to compute
     * what token(s) can come next and specifically: outside of a lookahead decision.
     * That is what you want for error reporting and recovery upon parse error.
     *
     * @param {number} stateNumber the ATN state number
     * @param {org.antlr.v4.runtime.RuleContext} context the full parse context
     * @return {IntervalSet} The set of potentially valid input symbols which could follow the
     * specified state in the specified context.
     * @throws {Error} IllegalArgumentException if the ATN does not contain a state with
     * number {@code stateNumber}
     */
    getExpectedTokens(stateNumber, context) {
        if (stateNumber < 0 || stateNumber >= this.states.length) {
            throw new Error("Invalid state number.");
        }

        var ctx = context;
        var s = this.states[stateNumber];
        var following = this.nextTokens(s);
        if (!following.contains(Token.EPSILON)) {
            return following;
        }

        var expected = new IntervalSet();
        expected.addAll(following);
        expected.remove(Token.EPSILON);
        while (ctx != null && ctx.invokingState >= 0 && following.contains(Token.EPSILON)) {
            var invokingState = this.states[ctx.invokingState];
            var rt = /** @type {org.antlr.v4.runtime.atn.RuleTransition} */ (invokingState.transition(0));
            following = this.nextTokens(rt.followState);
            expected.addAll(following);
            expected.remove(Token.EPSILON);
            ctx = ctx.parent;
        }

        if (following.contains(Token.EPSILON)) {
            expected.add(Token.EOF);
        }

        return expected;
    }
}

/**
 * @type {number}
 */
ATN.INVALID_ALT_NUMBER = 0;


exports = ATN;
